# https://github.com/kosl/esphome-fake-eastron-SDM630-with-CTs
# GPIO7 - TX to RX of bottom RS485 module
# GPIO9 - RX to TX of bottom RS485 module
# GPIO20 - RX to RXD of top RS485 module
# GPIO21 - TX to TXD of top RS485 module
# GPIO6 - RX to RXD of middle RS485 module
# GPIO5 - TX to TXD of middle RS485 module

esphome:
  name: deye-bridge
  friendly_name: Deye bridge for SDM630, Solarman and PACE BMS
  min_version: 2026.1.0 
  devices: # https://esphome.io/components/esphome/#sub-devices
    - id: device_solaredge
      name: "Solaredge Inverter"
    - id: device_solaredge_meter1
      name: "Solaredge Meter 1"
    - id: modbus_rtu_bridge
      name: "Modbus TCP to RTU Bridge"
    # - id: pace_battery1
    #   name: "Battery pack 1"
    # - id: pace_battery2
    #   name: "Battery pack 2"


esp32:
  board: esp32-c3-devkitc-02
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_LWIP_MAX_SOCKETS: '16'

# Enable logging
logger:
  level: INFO
  #baud_rate: 0

api: # Enable Home Assistant API

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  output_power: 8.5dB
  power_save_mode: none  # Better reliability over power saving  

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Deye Fallback Hotspot"
    password: !secret wifi_password

captive_portal:

external_components:
  # - source: github://kosl/esphome_modbus_tcp_master@slow-async
  #   components: [modbus_tcp_manager]
  #   refresh: 0s  # Always use latest version during development
  - source:
      type: local
      path: external_components
    components: [modbus_tcp_manager]
  - source:
      type: git
      url: https://github.com/rosenrot00/esphome_modbus_bridge
    components: [modbus_bridge]


# Single connection manager for the Modbus device
modbus_tcp_manager:
  id: modbus_device
  host: "192.168.1.31"  # IP address of your Modbus TCP server
  port: 502              # Default Modbus TCP port
  unit_id: 1             # Modbus unit/slave ID
  connection_timeout: 3s
  read_timeout: 3s

uart:
  - id: uart_meter
    tx_pin: GPIO21
    rx_pin: GPIO20 
    baud_rate: 9600
    #debug:
    #  direction: BOTH
  # - id: uart_bus
  #   tx_pin: GPIO7
  #   rx_pin: GPIO9
  #   baud_rate: 9600
  #   rx_buffer_size: 256            # minimum 256 recommended; increase for long RTU responses
  - id: uart_bms
    baud_rate: 9600
    tx_pin: GPIO6
    rx_pin: GPIO5
    #debug:
    #  direction: BOTH


modbus:
  - id: modbus_eastron
    uart_id: uart_meter
    role: server # https://esphome.io/components/modbus_controller/#example-server
  - id: modbus_bms # https://github.com/syssi/esphome-pace-bms/blob/main/multiple-batteries-example/esp32-lilygo-can485-example.yaml
    uart_id: uart_bms
    send_wait_time: 200ms

# modbus_controller:
#   - id: bms0
#     address: "0x01"
#     modbus_id: modbus_bms
#     command_throttle: 200ms
#     update_interval: 10s

#   - id: bms1
#     address: "0x02"
#     modbus_id: modbus_bms
#     command_throttle: 200ms
#     update_interval: 10s
                   
# Include packages for Eastron and each battery pack
packages:
# Include packages for Eastron
  solaredge_meter: !include
    file: device-solaredge-tcp-sdm630.yaml
    vars:
      device_id_solaredge_inverter: device_solaredge
      device_id_solaredge_meter1: device_solaredge_meter1      
  # pack_1: !include
  #   file: pack.yaml
  #   vars:
  #     modbus_controller_id: bms0
  #     pack: Pack 1
  #     friendly_name: Pace BMS
  #     device_id: pace_battery1
  # pack_2: !include
  #   file: pack.yaml
  #   vars:
  #     modbus_controller_id: bms1
  #     pack: Pack 2
  #     friendly_name: Pace BMS
  #     device_id: pace_battery2
  energy_meter: !include
    file: device-sdm_meter.yaml
    vars:
      modbus_id: modbus_bms

sensor:

  - platform: template
    name: "TCP Clients"
    id: mb_tcp_clients
    accuracy_decimals: 0
    update_interval: never
    device_id: modbus_rtu_bridge
  
  # =========== Diagnostic sensors ===========
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    id: wifi_rssi
    update_interval: 1min  
    unit_of_measurement: "dBm"
    accuracy_decimals: 0
    device_class: signal_strength
    entity_category: diagnostic 


# Enable built-in status LED on GPIO8
light:
  - platform: status_led
    id: esp_status_led
    pin:
      number: GPIO8
      inverted: true
      ignore_strapping_warning: true 
    entity_category: diagnostic

# Modbus bridge configuration: TCP server <-> UART RTU translator
# modbus_bridge:
#   id: mb_bridge
#   uart_id: uart_bus
#   tcp_port: 502                  # TCP port to listen on
#   rtu_response_timeout: 3000     # ms, internally clamped to >=10 ms
#   # tcp_client_timeout: 60000    # ms of inactivity before client is disconnected
#   # tcp_allowed_clients: 2       # number of simultaneous TCP clients (min 1)
#   # tcp_poll_interval: 50        # ms between TCP polls
#   # de_pin: GPIO18               # Optional: RS-485 Driver Enable (DE)
#   # re_pin: GPIO19               # Optional: RS-485 Receiver Enable (/RE) - de_pin and re_pin can be the same GPIO
#   # (DE and /RE may be the same GPIO if the transceiver ties them together)
#   # crc_bytes_swapped: false     # allows to swap CRC byte order LO/HI -> HI/LO
#   # enabled: true                # allows to enable or disable during runtime
#   # uart_wake_loop_on_rx: true   # enable ESPHome's UART low latency setting (effects not yet tested)

#   # Event: triggered whenever number of TCP clients changes
#   on_tcp_clients_changed:
#     then:
#       - lambda: |-
#           id(tcp_clients) = count;
#       - logger.log:
#           format: "TCP clients connected: %d"
#           args: ['count']
#       - sensor.template.publish:
#             id: mb_tcp_clients
#             state: !lambda |-
#               return (int) count;

# Global variable to store connected TCP client count
# globals:
#   - id: tcp_clients
#     type: int
#     restore_value: no
#     initial_value: '0'
