esphome:
  name: deye-bridge
  friendly_name: Deye bridge for SDM630, Solarman and PACE BMS
  min_version: 2026.1.0 
  devices: # https://esphome.io/components/esphome/#sub-devices
    - id: energy_meter
      name: "Eastron SDM 630 (fake meter)"
    - id: modbus_rtu_bridge
      name: "Modbus TCP to RTU Bridge"
    - id: pace_battery1
      name: "Battery 1"
    - id: pace_battery2
      name: "Battery 2"


esp32:
  board: esp32-c3-devkitc-02
  framework:
    type: esp-idf

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  output_power: 8.5dB
  power_save_mode: none  # Better reliability over power saving  

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Deye Fallback Hotspot"
    password: "blablabla"

captive_portal:

external_components:
  - source:
      type: git
      url: https://github.com/rosenrot00/esphome_modbus_bridge
    components: [modbus_bridge]

uart:
  - id: uart_meter
    tx_pin: GPIO20
    rx_pin: GPIO21 
    baud_rate: 9600
    debug:
      direction: BOTH
  - id: uart_bus
    tx_pin: GPIO7
    rx_pin: GPIO9
    baud_rate: 9600
    # stop_bits: 1                 # Optional: Default is 1
    # parity: NONE                 # Optional: Default is NONE
    rx_buffer_size: 256            # minimum 256 recommended; increase for long RTU responses

# https://esphome.io/components/modbus_controller/#example-server
modbus:
  - uart_id: uart_meter
    id: modbus_eastron
    role: server

modbus_controller:
  - modbus_id: modbus_eastron
    address: 0x2 # Meter address
    server_registers:
      - address: 0x0000 # Phase 1 line to neutral volts.
        value_type: FP32
        read_lambda: |-
          return id(a_voltage_sensor).state;
      - address: 0x0002 # Phase 2 line to neutral volts.
        value_type: FP32
        read_lambda: |-
          return id(b_voltage_sensor).state;
      - address: 0x0004 # Phase 3 line to neutral volts.
        value_type: FP32
        read_lambda: |-
          return id(c_voltage_sensor).state;
      - address: 0x0006 # Phase 1 current.
        value_type: FP32
        read_lambda: |-
          return id(a_current_sensor).state;
      - address: 0x0008 # Phase 2 current.
        value_type: FP32
        read_lambda: |-
          return id(b_current_sensor).state;
      - address: 0x000A # Phase 3 current.
        value_type: FP32
        read_lambda: |-
          return id(b_current_sensor).state;
      - address: 0x000C # Phase 1 power.
        value_type: FP32
        read_lambda: |-
          return id(a_power_sensor).state;
      - address: 0x000C # Phase 2 power.
        value_type: FP32
        read_lambda: |-
          return id(b_power_sensor).state;
      - address: 0x0010 # Phase 1 power.
        value_type: FP32
        read_lambda: |-
          return id(c_power_sensor).state;     
      - address: 0x0012 # Phase 1 volt amps.
        value_type: FP32
        read_lambda: |-
          return id(a_power_sensor).state;
      - address: 0x0014 # Phase 2 volt amps.
        value_type: FP32
        read_lambda: |-
          return id(b_power_sensor).state;
      - address: 0x0016 # Phase 3 volt amps.
        value_type: FP32
        read_lambda: |-
          return id(c_power_sensor).state;  
      ###
      - address: 0x002E # Average line current.
        value_type: FP32
        read_lambda: |-
          return id(average_current_sensor).state;  
      - address: 0x0030 # Sum of line currents.
        value_type: FP32
        read_lambda: |-
          return id(total_current_sensor).state;  
      - address: 0x0034 # Total system power.
        value_type: FP32
        read_lambda: |-
          return id(total_act_power_sensor).state;
      - address: 0x0038 # Total system volt amps.
        value_type: FP32
        read_lambda: |-
          return id(total_act_power_sensor).state;
      - address: 0x0046 # Frequency of supply voltages.
        value_type: FP32
        read_lambda: |-
          return id(frequency_sensor).state;   
      - address: 0x004A # Export Wh since last reset.
        value_type: FP32
        read_lambda: |-
          return id(total_kwh_sensor).state;

                   
          

sensor:
  - platform: template
    name: "Phase A Voltage"
    id: a_voltage_sensor
    unit_of_measurement: "V"
    accuracy_decimals: 2

  - platform: template
    name: "Phase B Voltage"
    id: b_voltage_sensor
    unit_of_measurement: "V"
    accuracy_decimals: 2

  - platform: template
    name: "Phase C Voltage"
    id: c_voltage_sensor
    unit_of_measurement: "V"
    accuracy_decimals: 2

  # - platform: template
  #   name: "Phase A Current"
  #   id: a_current_sensor
  #   unit_of_measurement: "A"
  #   accuracy_decimals: 3

  # - platform: template
  #   name: "Phase B Current"
  #   id: b_current_sensor
  #   unit_of_measurement: "A"
  #   accuracy_decimals: 3

  # - platform: template
  #   name: "Phase C Current"
  #   id: c_current_sensor
  #   unit_of_measurement: "A"
  #   accuracy_decimals: 3

  - platform: template
    name: "Phase A Active Power"
    id: a_power_sensor
    unit_of_measurement: "W"
    accuracy_decimals: 1

  - platform: template
    name: "Phase B Active Power"
    id: b_power_sensor
    unit_of_measurement: "W"
    accuracy_decimals: 1

  - platform: template
    name: "Phase C Active Power"
    id: c_power_sensor
    unit_of_measurement: "W"
    accuracy_decimals: 1

  # - platform: template
  #   name: "Phase A Apparent Power"
  #   id: a_apparent_sensor
  #   unit_of_measurement: "VA"
  #   accuracy_decimals: 1

  # - platform: template
  #   name: "Phase B Apparent Power"
  #   id: b_apparent_sensor
  #   unit_of_measurement: "VA"
  #   accuracy_decimals: 1

  # - platform: template
  #   name: "Phase C Apparent Power"
  #   id: c_apparent_sensor
  #   unit_of_measurement: "VA"
  #   accuracy_decimals: 1

  # - platform: template
  #   name: "Phase A Power Factor"
  #   id: a_pf_sensor
  #   unit_of_measurement: ""
  #   accuracy_decimals: 3

  # - platform: template
  #   name: "Phase B Power Factor"
  #   id: b_pf_sensor
  #   unit_of_measurement: ""
  #   accuracy_decimals: 3

  # - platform: template
  #   name: "Phase C Power Factor"
  #   id: c_pf_sensor
  #   unit_of_measurement: ""
  #   accuracy_decimals: 3

  - platform: template
    name: "Average Line Current"
    id: average_current_sensor
    unit_of_measurement: "A"
    accuracy_decimals: 3

  - platform: template
    name: "Total Line Current"
    id: total_current_sensor
    unit_of_measurement: "A"
    accuracy_decimals: 3

  - platform: template
    name: "Total Active Power"
    id: total_act_power_sensor
    unit_of_measurement: "W"
    accuracy_decimals: 1

  # - platform: template
  #   name: "Total Apparent Power"
  #   id: total_aprt_power_sensor
  #   unit_of_measurement: "VA"
  #   accuracy_decimals: 1

  - platform: template
    name: "Supply Frequency"
    id: frequency_sensor
    unit_of_measurement: "Hz"
    accuracy_decimals: 2

  - platform: template
    name: "Total Energy kWh"
    id: total_kwh_sensor
    unit_of_measurement: "kWh"
    accuracy_decimals: 3

  # =========== Current sensors ===========
  - platform: adc
    id: cc_l1
    pin:
      number: GPIO2
      ignore_strapping_warning: true 
    attenuation: 6db
  - platform: ct_clamp
    sensor: cc_l1
    name: "Phase A Current"
    id: a_current_sensor
    unit_of_measurement: "A"
    accuracy_decimals: 3    
    update_interval: 30s
    filters:
      - median:
      - calibrate_linear:
          method: exact
          datapoints:
           - 0.0390 -> 0.0
           - 0.0630 -> 5.0
           - 0.1184 -> 11.0
           - 0.1665 -> 16.0
      - clamp:
          min_value: 0.0
  - platform: adc
    id: cc_l2
    pin: GPIO3
    attenuation: 6db
  - platform: ct_clamp
    sensor: cc_l2
    name: "Phase B Current"
    id: b_current_sensor
    update_interval: 30s
    filters:
      - median
      - calibrate_linear:
          method: exact
          datapoints:
           - 0.0380 -> 0.0
           - 0.0611 -> 5.0
           - 0.1167 -> 11.0
           - 0.1646 -> 16.0
      - clamp:
          min_value: 0.0
  - platform: adc
    id: cc_l3
    pin: GPIO4
    attenuation: 6db
  - platform: ct_clamp
    sensor: cc_l3
    name: "Phase C Current"
    id: c_current_sensor
    update_interval: 30s
    filters:
      - median
      - calibrate_linear:
          method: exact
          datapoints:
           - 0.0380 -> 0.0
           - 0.0607 -> 5.0
           - 0.1160 -> 11.0
           - 0.1644 -> 16.0
      - clamp:
          min_value: 0.0


  - platform: template
    name: "TCP Clients"
    id: mb_tcp_clients
    accuracy_decimals: 0
    update_interval: never
  
  # =========== Diagnostic sensors ===========
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    id: wifi_rssi
    update_interval: 1min  
    unit_of_measurement: "dBm"
    accuracy_decimals: 0
    device_class: signal_strength
    entity_category: diagnostic 




# Enable built-in status LED on GPIO8
light:
  - platform: status_led
    id: esp_status_led
    pin:
      number: GPIO8
      inverted: true
      ignore_strapping_warning: true 

# Modbus bridge configuration: TCP server <-> UART RTU translator
modbus_bridge:
  id: mb_bridge
  uart_id: uart_bus
  tcp_port: 502                  # TCP port to listen on
  rtu_response_timeout: 3000     # ms, internally clamped to >=10 ms
  # tcp_client_timeout: 60000    # ms of inactivity before client is disconnected
  # tcp_allowed_clients: 2       # number of simultaneous TCP clients (min 1)
  # tcp_poll_interval: 50        # ms between TCP polls
  # de_pin: GPIO18               # Optional: RS-485 Driver Enable (DE)
  # re_pin: GPIO19               # Optional: RS-485 Receiver Enable (/RE) - de_pin and re_pin can be the same GPIO
  # (DE and /RE may be the same GPIO if the transceiver ties them together)
  # crc_bytes_swapped: false     # allows to swap CRC byte order LO/HI -> HI/LO
  # enabled: true                # allows to enable or disable during runtime
  # uart_wake_loop_on_rx: true   # enable ESPHome's UART low latency setting (effects not yet tested)

  # Event: triggered whenever number of TCP clients changes
  on_tcp_clients_changed:
    then:
      - lambda: |-
          id(tcp_clients) = count;
      - logger.log:
          format: "TCP clients connected: %d"
          args: ['count']
      - sensor.template.publish:
            id: mb_tcp_clients
            state: !lambda |-
              return (int) count;

# Global variable to store connected TCP client count
globals:
  - id: tcp_clients
    type: int
    restore_value: no
    initial_value: '0'
