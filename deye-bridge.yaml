# https://github.com/kosl/esphome-fake-eastron-SDM630-with-CTs
# This is a bridge for Deye Inv-Meter2 addon, where Eastron SDM630 RS485/RTU
# is emulated from Solaredge SE17K inverter using Modbus/TCP client.
# In addition it provides Modbus/TCP to Modbus RTU bridge for Solarman integration.

esphome:
  name: energy-meter
  friendly_name: Deye bridge for SDM630 and Solarman
  min_version: 2026.1.0 
  devices: # https://esphome.io/components/esphome/#sub-devices
    - id: device_solaredge
      name: "Solaredge Inverter"
    - id: device_solaredge_meter1
      name: "Solaredge Meter 1"
  on_boot:
    priority: 600  # Medium-high priority (after WiFi connects)
    then:
      - light.turn_on:
          id: onboard_rgb_led
          red: 50%
          green: 0%
          blue: 50%
          brightness: 50%
      - lambda: |-
          id(mb_bridge_enabled).publish_state(id(modbus_rtu_bridge).is_enabled());


esp32:
  board: esp32-s3-fh4r2 # ESP32-S3 zero board
  framework:
    type: esp-idf
#    sdkconfig_options:
#      CONFIG_LWIP_MAX_SOCKETS: '16'

# Enable logging
logger:
  level: INFO
  baud_rate: 0
  logs:
    sensor: INFO
    modbus_tcp_manager: INFO
    

  

api: # Enable Home Assistant API

ota:
  - platform: esphome

wifi:
  networks:
    - ssid: !secret wifi_eteradxa_ssid
      password: !secret wifi_password
    - ssid: !secret wifi_garaza_ssid
      password: !secret wifi_password
    - ssid: !secret wifi_ssid
      password: !secret wifi_password
  output_power: 8.5dB
  power_save_mode: none  # Better reliability over power saving  

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Deye Fallback Hotspot"
    password: !secret wifi_password

captive_portal:

external_components:
  # https://github.com/esphome/esphome/issues/12183$0
  - source: github://pr#11969
    components: [modbus, modbus_controller, modbus_server]
    refresh: 1h  
  - source:
      type: git
      url: https://github.com/rosenrot00/esphome_modbus_bridge
    components: [modbus_bridge]
  - source: github://kosl/esphome_modbus_tcp_master@slow-async
    components: [modbus_tcp_manager]
    refresh: 1d  # Set 0s for latest version during development
  # - source:
  #     type: local
  #     path: external_components
  #   components: [modbus_tcp_manager]


# Single connection manager for the Modbus TCP device (Solaredge)
modbus_tcp_manager:
  id: modbus_device
  host: "192.168.1.31"  # IP address of your Modbus TCP server
  port: 502              # Default Modbus TCP port
  unit_id: 1             # Modbus unit/slave ID
  connection_timeout: 3s
  read_timeout: 3s

uart:
  # GPIO4 - RX to RXD of top RS485 module
  # GPIO5 - TX to TXD of top RS485 module
  - id: uart_meter
    rx_pin: GPIO4
    tx_pin: GPIO5
    baud_rate: 9600
    rx_buffer_size: 256
    debug:
      direction: BOTH
  # GPIO3 - RX to RXD of middle RS485 module
  # GPIO1 - TX to TXD of middle RS485 module
  - id: uart_rtu_bridge
    rx_pin: GPIO3
    tx_pin: GPIO1
    baud_rate: 9600
    rx_buffer_size: 256 # minimum 256 recommended; increase for long RTU responses

modbus:
  - id: modbus_meter
    uart_id: uart_meter
    role: server # https://esphome.io/components/modbus_controller/#example-server
  # - id: modbus_rtu_bridge # for testing with SMD meter
  #   uart_id: uart_rtu_bridge
  #   send_wait_time: 200ms
                   
# Include packages for Eastron and each battery pack
packages:
# Include packages for Eastron
  solaredge_meter: !include
    file: device-solaredge-tcp-sdm630.yaml
    vars:
      modbus_id: modbus_meter
      device_id_solaredge_inverter: device_solaredge
      device_id_solaredge_meter1: device_solaredge_meter1
  # energy_meter: !include
  #   file: device-sdm_meter.yaml
  #   vars:
  #     modbus_id: modbus_rtu_bridge

  
# =========== Diagnostic sensors ===========
# Enable built-in status LED on GPIO8
light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    chipset: ws2812
    pin: 
      number: GPIO21
    num_leds: 1
    name: "Onboard RGB LED"
    id: onboard_rgb_led
    entity_category: diagnostic

button:
  - platform: restart
    entity_category: diagnostic
    name: Restart

sensor:
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    id: wifi_rssi
    update_interval: 1min  
    unit_of_measurement: "dBm"
    accuracy_decimals: 0
    device_class: signal_strength
    entity_category: diagnostic 


# sensor:
  - platform: template
    name: "TCP Clients"
    id: mb_tcp_clients
    accuracy_decimals: 0
    update_interval: never

# Modbus bridge configuration: TCP server <-> UART RTU translator
modbus_bridge:
  id: modbus_rtu_bridge
  uart_id: uart_rtu_bridge
  tcp_port: 502                  # TCP port to listen on
  rtu_response_timeout: 400      # ms, internally clamped to >=10 ms.  Deye responses are around 320 ms @ 9600 baud
  # tcp_client_timeout: 60000    # ms of inactivity before client is disconnected
  # tcp_allowed_clients: 2       # number of simultaneous TCP clients (min 1)
  # tcp_poll_interval: 50        # ms between TCP polls
  # de_pin: GPIO18               # Optional: RS-485 Driver Enable (DE)
  # re_pin: GPIO19               # Optional: RS-485 Receiver Enable (/RE) - de_pin and re_pin can be the same GPIO
  # (DE and /RE may be the same GPIO if the transceiver ties them together)
  # crc_bytes_swapped: false     # allows to swap CRC byte order LO/HI -> HI/LO
  # enabled: true                # allows to enable or disable during runtime
  # uart_wake_loop_on_rx: true   # enable ESPHome's UART low latency setting (effects not yet tested)

  # Event: triggered whenever number of TCP clients changes
  on_tcp_clients_changed:
    then:
      - lambda: |-
          id(tcp_clients) = count;
      - logger.log:
          format: "TCP clients connected: %d"
          args: ['count']
      - sensor.template.publish:
            id: mb_tcp_clients
            state: !lambda |-
              return (int) count;
switch:
  # Switch: enable/disable verbose Modbus debugging
  - platform: template
    name: "Modbus Bridge Debug"
    id: modbus_debug_switch
    restore_mode: RESTORE_DEFAULT_OFF
    turn_on_action:
      - lambda: |-
          id(modbus_rtu_bridge).set_debug(true);
          id(modbus_debug_switch).publish_state(true);
    turn_off_action:
      - lambda: |-
          id(modbus_rtu_bridge).set_debug(false);
          id(modbus_debug_switch).publish_state(false);

  # Switch: enable/disable the Modbus bridge itself
  - platform: template
    id: mb_bridge_enabled
    name: "Modbus Bridge Enabled"
    restore_mode: "ALWAYS_ON"
    optimistic: true
    turn_on_action:
      - lambda: |-
          id(modbus_rtu_bridge).set_enabled(true);
    turn_off_action:
      - lambda: |-
          id(modbus_rtu_bridge).set_enabled(false);

#Global variable to store connected TCP client count
globals:
  - id: tcp_clients
    type: int
    restore_value: no
    initial_value: '0'
