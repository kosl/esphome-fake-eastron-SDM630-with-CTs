# https://github.com/kosl/esphome-fake-eastron-SDM630-with-CTs

esphome:
  name: deye-bridge
  friendly_name: Deye bridge for SDM630, Solarman and PACE BMS
  min_version: 2026.1.0 
  devices: # https://esphome.io/components/esphome/#sub-devices
    - id: device_energy_meter
      name: "Eastron SDM 630 (fake meter)"
    - id: modbus_rtu_bridge
      name: "Modbus TCP to RTU Bridge"
    - id: pace_battery1
      name: "Battery pack 1"
    - id: pace_battery2
      name: "Battery pack 2"


esp32:
  board: esp32-c3-devkitc-02
  framework:
    type: esp-idf

# Enable logging
logger:
  level: INFO

# Enable Home Assistant API
api:

ota:
  - platform: esphome

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  output_power: 8.5dB
  power_save_mode: none  # Better reliability over power saving  

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Deye Fallback Hotspot"
    password: "blablabla"

captive_portal:

external_components:
  - source:
      type: git
      url: https://github.com/rosenrot00/esphome_modbus_bridge
    components: [modbus_bridge]

uart:
  - id: uart_meter
    tx_pin: GPIO20
    rx_pin: GPIO21 
    baud_rate: 9600
    debug:
      direction: BOTH
  - id: uart_bus
    tx_pin: GPIO7
    rx_pin: GPIO9
    baud_rate: 9600
    # stop_bits: 1                 # Optional: Default is 1
    # parity: NONE                 # Optional: Default is NONE
    rx_buffer_size: 256            # minimum 256 recommended; increase for long RTU responses
  - id: uart_bms
    baud_rate: 9600
    tx_pin: GPIO5
    rx_pin: GPIO6
    debug:
      direction: BOTH
      dummy_receiver: false


modbus:
  - id: modbus_eastron
    uart_id: uart_meter
    role: server # https://esphome.io/components/modbus_controller/#example-server
  - id: modbus_bms # https://github.com/syssi/esphome-pace-bms/blob/main/multiple-batteries-example/esp32-lilygo-can485-example.yaml
    uart_id: uart_bms
    send_wait_time: 200ms


modbus_controller:
  - id: bms0
    address: "0x01"
    modbus_id: modbus_bms
    command_throttle: 200ms
    update_interval: 10s

  - id: bms1
    address: "0x02"
    modbus_id: modbus_bms
    command_throttle: 200ms
    update_interval: 10s
                   
# Include packages for Eastron and each battery pack
packages:
  energy_meter: !include
    file: fake-eastron.yaml
    vars:
      ct_update_interval: 5s
      energy_meter_device_id: device_energy_meter
      
  pack_1: !include
    file: pack.yaml
    vars:
      modbus_controller_id: bms0
      pack: Pack 1
      friendly_name: Pace BMS
  pack_2: !include
    file: pack.yaml
    vars:
      modbus_controller_id: bms1
      pack: Pack 2
      friendly_name: Pace BMS

sensor:

  - platform: template
    name: "TCP Clients"
    id: mb_tcp_clients
    accuracy_decimals: 0
    update_interval: never
    device_id: modbus_rtu_bridge
  
  # =========== Diagnostic sensors ===========
  - platform: wifi_signal
    name: "WiFi Signal Strength"
    id: wifi_rssi
    update_interval: 1min  
    unit_of_measurement: "dBm"
    accuracy_decimals: 0
    device_class: signal_strength
    entity_category: diagnostic 


# Enable built-in status LED on GPIO8
light:
  - platform: status_led
    id: esp_status_led
    pin:
      number: GPIO8
      inverted: true
      ignore_strapping_warning: true 
    entity_category: diagnostic

# Modbus bridge configuration: TCP server <-> UART RTU translator
modbus_bridge:
  id: mb_bridge
  uart_id: uart_bus
  tcp_port: 502                  # TCP port to listen on
  rtu_response_timeout: 3000     # ms, internally clamped to >=10 ms
  # tcp_client_timeout: 60000    # ms of inactivity before client is disconnected
  # tcp_allowed_clients: 2       # number of simultaneous TCP clients (min 1)
  # tcp_poll_interval: 50        # ms between TCP polls
  # de_pin: GPIO18               # Optional: RS-485 Driver Enable (DE)
  # re_pin: GPIO19               # Optional: RS-485 Receiver Enable (/RE) - de_pin and re_pin can be the same GPIO
  # (DE and /RE may be the same GPIO if the transceiver ties them together)
  # crc_bytes_swapped: false     # allows to swap CRC byte order LO/HI -> HI/LO
  # enabled: true                # allows to enable or disable during runtime
  # uart_wake_loop_on_rx: true   # enable ESPHome's UART low latency setting (effects not yet tested)

  # Event: triggered whenever number of TCP clients changes
  on_tcp_clients_changed:
    then:
      - lambda: |-
          id(tcp_clients) = count;
      - logger.log:
          format: "TCP clients connected: %d"
          args: ['count']
      - sensor.template.publish:
            id: mb_tcp_clients
            state: !lambda |-
              return (int) count;

# Global variable to store connected TCP client count
globals:
  - id: tcp_clients
    type: int
    restore_value: no
    initial_value: '0'
